/* rest-api.js â€” safe, minimal, non-blocking gateway init
   Keeps original flow, minimal changes.
*/
const express = require('express');
const bodyParser = require('body-parser');
const roleAuth = require('./middleware/roleAuth');
const fs = require('fs');
const path = require('path');

// connectGateway may return either { contract, gateway, client } or { gateway, client, contract }
let connectGateway;
try {
  connectGateway = require('./src/app').connectGateway || require('./src/app').initializeGateway || require('./src/app');
} catch (e) {
  // if require fails, we'll try to call it later and log the error
  connectGateway = null;
  console.error('WARN: could not require ./src/app â€” will attempt to require at runtime:', e.message);
}

const PORT = process.env.PORT || 3000;
const CONTRACT_RETRY_MS = parseInt(process.env.CONTRACT_RETRY_MS || '30000', 10);
const CONTRACT_RETRY_INTERVAL = parseInt(process.env.CONTRACT_RETRY_INTERVAL || '1000', 10);

// --- Phone map persistence (new) ---
const DATA_DIR = process.env.DATA_DIR || path.join(__dirname, 'data');
const PHONE_MAP_FILE = path.join(DATA_DIR, 'phone-map.json');
let phoneMap = Object.create(null);

function normalizePhone(p) {
  if (!p) return null;
  let s = String(p).trim().replace(/\s+/g, '');
  if (s.startsWith('00')) s = '+' + s.slice(2); // 00.. -> +..
  return s; // keep as provided otherwise (caller should prefer E.164 like +254...)
}

function ensureDataDir() {
  try { if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true }); } catch {}
}

function loadPhoneMapSync() {
  ensureDataDir();
  try {
    const buf = fs.readFileSync(PHONE_MAP_FILE, 'utf8');
    const obj = JSON.parse(buf);
    if (obj && typeof obj === 'object') phoneMap = obj;
  } catch { phoneMap = Object.create(null); }
}

async function savePhoneMap() {
  await fs.promises.mkdir(DATA_DIR, { recursive: true });
  const tmp = PHONE_MAP_FILE + '.tmp';
  await fs.promises.writeFile(tmp, JSON.stringify(phoneMap, null, 2), 'utf8');
  await fs.promises.rename(tmp, PHONE_MAP_FILE);
}

loadPhoneMapSync();
// --- end phone map block ---

const app = express();
app.use(bodyParser.json());

// debug request logger (temporary)
app.use((req, _res, next) => { console.log(">>> REQ", req.method, req.url); next(); });

// Auth middleware
if (process.env.DISABLE_AUTH === 'true') {
  console.warn('âš ï¸  Auth middleware disabled for testing');
} else {
  app.use(roleAuth());
}

// readiness state
let contractConn = null;   // object returned from connectGateway
let contractReady = false;

// ALWAYS respond immediately to /test and /health
app.get('/health', (_req, res) => res.json({ ok: true }));
app.get('/test', (_req, res) => res.send(contractReady ? 'pong' : 'Service initializing'));

// --- New endpoints: phone registration & lookup (do NOT require contractReady) ---
app.post('/registerPhone', async (req, res) => {
  try {
    const phone = normalizePhone(req.body && req.body.phone);
    const farmID = req.body && req.body.farmID;
    if (!phone || !farmID) return res.status(400).json({ error: 'phone and farmID required' });

    phoneMap[phone] = { farmID, updatedAt: new Date().toISOString() };
    await savePhoneMap();
    return res.json({ ok: true, phone, farmID });
  } catch (e) {
    console.error('registerPhone error:', e.message || e);
    return res.status(500).json({ error: 'Failed to persist mapping' });
  }
});

app.get('/lookupPhone/:phone', (req, res) => {
  const phone = normalizePhone(req.params.phone);
  const entry = phoneMap[phone];
  if (!entry) return res.status(404).json({ error: 'not found' });
  return res.json({ phone, farmID: entry.farmID, updatedAt: entry.updatedAt });
});
// --- end new endpoints ---

// POST /records -> IssueRecord: sends single JSON-string arg
app.post('/records', async (req, res) => {
  if (!contractReady) return res.status(503).json({ error: 'Service initializing' });

  try {
    const record = {
      ID: req.body.ID,
      farmID: req.body.farmID,
      methanePPM: req.body.methanePPM,
      timestamp: req.body.timestamp,
    };
    // support both shapes of contractConn (contractConn.contract or contractConn)
    const contract = contractConn.contract || contractConn;
    await contract.submitTransaction('IssueRecord', JSON.stringify(record));
    res.json({ success: true, ID: record.ID });
  } catch (err) {
    console.error('Error issuing record:', err && err.message ? err.message : err);
    res.status(500).json({ error: err && err.message ? err.message : String(err) });
  }
});

// GET /records/:id -> ReadRecord
app.get('/records/:id', async (req, res) => {
  if (!contractReady) return res.status(503).json({ error: 'Service initializing' });

  const { id } = req.params;
  try {
    const contract = contractConn.contract || contractConn;
    const resultBytes = await contract.evaluateTransaction('ReadRecord', id);
    const resultString = resultBytes.toString('utf8').trim();

    // Try to parse JSON. If chaincode returned ASCII codes like "123,34,..."
    // detect and convert that to a string then parse.
    try {
      let record;

      // Try direct JSON parse first
      try {
        record = JSON.parse(resultString);
      } catch (parseErr) {
        // If string looks like comma-separated numbers, convert to chars and parse
        const asciiCsvRegex = /^\s*\d+(?:\s*,\s*\d+)*\s*$/;
        if (asciiCsvRegex.test(resultString)) {
          const maybeAscii = resultString
            .split(',')
            .map(n => String.fromCharCode(Number(n)))
            .join('');
          record = JSON.parse(maybeAscii);
        } else {
          // Not JSON and not ASCII CSV -> rethrow to outer catch
          throw parseErr;
        }
      }

      if (!record || Object.keys(record).length === 0) {
        return res.status(404).json({ error: `Record ${id} not found` });
      }
      return res.json(record);
    } catch (e) {
      // parsing error (either JSON.parse failed or ascii->string parse failed)
      console.error("âŒ Parse failure:", e && e.message ? e.message : e, "Raw:", resultString);
      return res.status(500).json({ error: "Invalid JSON response", raw: resultString });
    }
  } catch (err) {
    // Error from evaluateTransaction or other failures contacting Fabric
    console.error(`âŒ Failed to read record ${id}:`, err && err.message ? err.message : err);
    return res.status(500).json({ error: err && err.message ? err.message : String(err) });
  }
});

// Start HTTP server immediately (non-blocking)
const server = app.listen(PORT, '0.0.0.0', () =>
  console.log(`ðŸš€ REST API listening on http://127.0.0.1:${PORT}`)
);

// Background: try to load gateway & contract with throttled retries
async function tryConnect() {
  const start = Date.now();
  const timeout = CONTRACT_RETRY_MS;
  console.log('DEBUG: Starting background Fabric Gateway initialization...');
  while (Date.now() - start < timeout) {
    try {
      if (!connectGateway) {
        // attempt require again (helps when user changed src/app exports)
        try {
          connectGateway = require('./src/app').connectGateway || require('./src/app').initializeGateway || require('./src/app');
        } catch (e) {
          console.debug('DEBUG: require(./src/app) failed, will retry:', e.message);
        }
      }
      if (!connectGateway) {
        await new Promise(r => setTimeout(r, CONTRACT_RETRY_INTERVAL));
        continue;
      }

      const maybeConn = await Promise.race([
        // allow connectGateway to fail fast if it does
        connectGateway(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('connectGateway timeout')), 5000))
      ]);

      if (maybeConn) {
        // accept either contract in top-level or nested .contract
        const contract = maybeConn.contract || maybeConn;
        if (contract && typeof contract.evaluateTransaction === 'function') {
          contractConn = maybeConn;
          contractReady = true;
          console.log('DEBUG: Gateway initialized and contract available.');
          return;
        }
      }
      console.debug('DEBUG: Gateway initialized but contract not ready; retrying...');
    } catch (e) {
      console.debug('DEBUG: connectGateway attempt error:', e && e.message ? e.message : String(e));
    }
    await new Promise(r => setTimeout(r, CONTRACT_RETRY_INTERVAL));
  }
  console.error('ERROR: Gateway initialized but contract not available after retries.');
}

// Launch background attempt (no await so server keeps responding)
tryConnect().catch(e => console.error('ERROR in background tryConnect:', e && e.stack ? e.stack : e));

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nðŸ›‘ Shutting down server gracefully...');
  server.close(() => {
    console.log('âœ… Server closed. Exiting.');
    process.exit(0);
  });
});
